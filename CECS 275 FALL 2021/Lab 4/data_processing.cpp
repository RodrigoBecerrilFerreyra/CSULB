/*
* This C++ program reads numbers from a text file and processes frequencies
* of the values within the file to be printed in a new text file.
* CECS 275 - Fall 2021
* @author Ethan Hua
* @author Rodrigo Becerril Ferreyra
* @version 4.42
*
*/

#include <iostream>  // Used for simple I/O
#include <fstream>   // Used to open data file and save to frequency file
#include <iomanip>   // Used to format "averages" output in frequency file
#include <vector>    // Used to store information gleaned from data file

using namespace std;

// Function prototypes
void readData(vector<int>&);
double processData(vector<int>&,vector<int>&,vector<int>&);
void storeData(vector<int>&,vector<int>&,double);


int main(){
    // 3 vectors; only 1 of definite size given instructions from prompt
    // Input values from file will only range from 1 to 50.
    vector<int> receive;         // The input stream from the "data.txt"
                                 // Variable size.
    vector<int> counts (50,0);   // Store of counts for every number in range.
                                 // Assumed to always have size of 50.
    vector<int> highFreq;        // Store of which numbers occur most frequently.
                                 // Variable size.

    
    readData(receive);

    double fileAvg = processData(receive,counts,highFreq);

    storeData(counts,highFreq,fileAvg);

    //This section contains debugging code used to verify from within program.
    // int checkReceive = receive.size();
    // cout << "Input stream is " << checkReceive << " values long." << endl;
    
    // for(int ver = 0; ver < 50; ver++){
    //     cout << "Item at index " << ver << " yields " << counts[ver] << endl;
    // }

    // int checkFreq = highFreq.size();
    // cout << "There were " << checkFreq << " high frequency numbers." << endl;

    // cout << "Average is " << fileAvg << endl;

    return 0;
}

/**
 * Function attempts to access a specified file and begins writing to
 * a vector if the file was successfully found and outputs an alert if
 * such a file was not found.
 * @param data Vector to save each new data point to.
 * 
*/
void readData(vector<int>& data){

    ifstream inFile;

    int currentNum = 0;
    char comma;

    inFile.open("data.txt");

    if(inFile.is_open()){ // Stores file only if found.
        while(inFile >> currentNum){
            data.push_back(currentNum);
            inFile >> comma;
        }
    } else { // Alert user file was not found.
        cout << "Error: Could not find file." << endl;
        cout << "Please ensure the file \"data.txt\" is located" << endl;
        cout << "in this program's directory." << endl;
    }

    inFile.close();
    // Stops reading file at end of function call.
}

/**
 * Function takes a specified vector filled with data and attempts to
 * populate two other vectors with information based on the initial
 * vector. Also calculates the average of the values in the initial
 * vector.
 * @param data  Unprocessed, raw data vector most likely generated by readData
 * @param store Vector assumed to be 50 elements wide used to store the
 *              frequency count of inputs values 1 through 50
 *              originating in the input data vector
 * @param mode  Vector containing which values occurred the most frequently
 *              from the original input data vector
 * @return Average of all elements from the original data vector
 * 
*/
double processData(vector<int> &data, vector<int> &store, vector<int> &mode){
    
    const int storeSize = 50;  
    // Assumed that store parameter is 50 elements.

    int dataSize = data.size(); 
    // "data" parameter variable size; verified here

    int storeCount = 0;
    int currentMode = 0;

    double average = 0;

    /*
    "data" counter loop; information placed in "store" parameter.
    Index begins at 1 and ends at 51 to reflect ranging assumptions.
    */
    for(int sIndex = 1; sIndex < 51; sIndex++){
        // Index begins at 0 to reflect C++ data constraints
        for(int dIndex = 0; dIndex < dataSize; dIndex++){
            if (data[dIndex] == sIndex) {
                store[sIndex-1]++;
                // Must subtract 1 from this index to properly match
                // index value in "store" parameter
            }
        }
    }

    /*
    Highest-frequency extraction loop
    Used to identify the highest number of occurrences.
    */
    for(int countIndex = 0; countIndex < storeSize; countIndex++){
        if (store[countIndex] > currentMode) {
            currentMode = store[countIndex];
            // cout << "Current mode is " << currentMode << endl;
        }
    }

    /*
    Highest-frequency linear search algorithm
    Stores the numbers whose frequencies match the stored-highest in
    "mode" vector by use of "push_back" function.
    */
    for(int modeIndex = 0; modeIndex < storeSize; modeIndex++){
        if (store[modeIndex] == currentMode) {
            mode.push_back(modeIndex+1);
            // cout << "Mode was found at " << modeIndex+1 << endl;
        }
    }

    /* 
    Average of "data" elements calculation loop
    Takes value from "store" vector index, multiplies it by the 
    corresponding real-value number associated with index, and sums
    it up with previous results. Also sums how many elements in total.
    */
    for(int avgIndex = 0; avgIndex < storeSize; avgIndex++){
        average += store[avgIndex] * (avgIndex+1);
        storeCount += store[avgIndex];
    }
    // Obtains true average by dividing total of elements with total count.
    average = average / storeCount;

    return average;
}

/**
 * Function generates a print-out using the collected/processed data from
 * previous processData function by accepting its populated vectors and the
 * calculated average of elements.
 * @param counter   Vector that contains the counts of number occurrences in
 *                  the original data file.
 * @param frequency Vector that contains the numbers that occurred the most in
 *                  the original data file.
 * @param mean      Raw average value of the elements calculated by dividing
 *                  the sum of each element by the number of elements.
 * 
*/
void storeData(vector<int> &counter, vector<int> &frequency, double mean){

    ofstream outFile;

    outFile.open("frequency.txt");

    const int counterSize = 50;
    // Assumes that counter vector is only 50 elements wide, consistent with
    // design specifications and previous assumptions.

    int starCount = 0;
    // Counter used to print "*" in file.

    int freqSize = frequency.size();
    // Obtains count of numbers that occurred the most frequently.
    int freqCtl = 0;
    // Used to control printing frequency in the case of at least 3 numbers 
    // all occurring the most frequently.

    int finalCount = 0;
    // Re-count the total number of values recorded in original file.

    /* 
    Number-and-star printing loop
    Prints value from 1 to 50 and represents occurrences by printing
    a star for each time that number was counted.
    */
    for(int printIndex = 1; printIndex < 51; printIndex++){
        outFile << printIndex << ":";
        starCount = 0; // Reset star counter between prints
        while(starCount < counter[printIndex-1]){
            // Index must subtract 1 to correctly access corresponding value
            outFile << "*";
            starCount++;
        }
        outFile << endl;
        // New line after every number
    }

    // Frequency-display print control
    if (freqSize == 1) { // Only 1 most-frequent value
        outFile << "#" << frequency[0] << " occur the most." << endl;
    } else if (freqSize == 2) { // Only 2 most-frequent values
        outFile << "#" << frequency[0] << " and #" << frequency[1];
        outFile << " occurs the most." << endl;
    } else { // At least 3 most-frequent values
        while (freqCtl < freqSize) {
            if ((freqCtl + 1) == freqSize) { // Timing control for last value
                outFile << "and #" << frequency[freqSize-1] << " occur the most.";
                outFile << endl;
                freqCtl++;
            } else { // Prints generic case as long as not last value
                outFile << "#" << frequency[freqCtl] << ", ";
                freqCtl++;
            }
        }
    }

    // Element counter loop
    // Sum of how many numbers were stored in file.
    for(int numb = 0; numb < counterSize; numb++){
        finalCount += counter[numb];
    }

    outFile << "There are " << finalCount << " numbers. " << endl;
    outFile << "The average is " << setprecision(2) << fixed 
            << mean << "." << endl;

    outFile.close();
    // Stops writing to file at end of function call.
}
